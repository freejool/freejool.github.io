<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://freejool.github.io</id>
    <title>Gridea</title>
    <updated>2022-03-06T07:55:20.327Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://freejool.github.io"/>
    <link rel="self" href="https://freejool.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://freejool.github.io/images/avatar.png</logo>
    <icon>https://freejool.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[JavaScript 学习笔记 00]]></title>
        <id>https://freejool.github.io/post/javascript-xue-xi-bi-ji-00/</id>
        <link href="https://freejool.github.io/post/javascript-xue-xi-bi-ji-00/">
        </link>
        <updated>2022-03-05T04:26:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="脚本调用策略">脚本调用策略</h1>
<p>HTML 元素是按其在页面中出现的次序调用的，如果用 JavaScript 来管理页面上的元素（更精确的说法是使用 文档对象模型 DOM），若 JavaScript 加载于欲操作的 HTML 元素之前，则代码将<strong>出错</strong>。比如在要操作的 HTML 元素之前的<code>&lt;head&gt;</code>中使用<code>&lt;script&gt;</code>直接嵌入js代码，或者使用<code>&lt;script src&gt;</code>引用js文件，因为该元素未被加载时无法被引用。</p>
<p>解决方案分为内部和外部：</p>
<pre><code class="language-javascript">//内部
document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
  . . .
});
</code></pre>
<p><code>DOMContentLoaded</code>是一个<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Building_blocks/Events">事件</a>，而组合起来是一个<strong>事件监听器</strong>。他的工作就是监听“HTML加载完成”事件，当该事件发生后（HTML加载完成后），执行<code>. . .</code>处的代码。</p>
<pre><code class="language-javascript">//外部
&lt;script src=&quot;script.js&quot; async&gt;&lt;/script&gt;
</code></pre>
<p>这里使用了 JavaScript 的一项现代技术（async “异步”属性）来解决这一问题，它告知浏览器在遇到 <code>&lt;script&gt;</code> 元素时不要中断后续 HTML 内容的加载。</p>
<p>然而，由于浏览器遇到<code>async</code>时将不阻塞之后 HTML 元素的渲染或 JavaScript 代码的执行，在有多个 JavaScript 外联代码的时候，将导致<strong>乱序执行</strong>。这在 JavaScript 文件互相独立的时候无伤大雅，但相互有关联的时候就会出错。</p>
<p>于是就有了<code>defer</code>属性。它仅仅允许 HTML 元素和 JavaScript 代码直接的乱序，而保证 JavaScript 代码之间的顺序执行。但是显然<code>defer</code>的性能不如<code>async</code>。</p>
<h2 id="小结">小结：</h2>
<ul>
<li>如果脚本无需等待页面解析，且无依赖独立运行，那么无需添加属性。</li>
<li>如果脚本需要等待页面解析，且无依赖独立运行，那么应使用 <code>async</code>。</li>
<li>如果脚本需要等待页面解析，且依赖于其它脚本，调用这些脚本时应使用 <code>defer</code>，将关联的脚本按所需顺序置于 HTML 中。</li>
</ul>
<h1 id="注释">注释</h1>
<p><code>C</code>风格的注释。行注释<code>//</code>，多行注释<code>/*...*/</code>。</p>
<h1 id="猜数游戏">猜数游戏</h1>
<pre><code>开发一个猜数字游戏。游戏应随机选择一个 100 以内的自然数, 然后邀请玩家在 10 轮以内猜出这个数字。每轮后都应告知玩家的答案正确与否，如果出错了，则告诉他数字是低了还是高了。并且应显示出玩家前一轮所猜的数字。一旦玩家猜对，或者用尽所有机会，游戏将结束。游戏结束后，可以让玩家选择再次开始。
</code></pre>
<p>使用关键字 <code>let</code> （旧代码中使用 var）和一个名字来创建变量（参阅 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Variables#var_%E4%B8%8E_let_%E7%9A%84%E5%8C%BA%E5%88%AB">let 和 var 之间的区别</a>）。常量用于存储不希望更改的数据，用关键字 <code>const</code> 创建。</p>
<p>使用关键字 <code>function</code> 创建函数</p>
<pre><code class="language-javascript">function checkGuess() {
  alert('我是一个占位符');
}
//展示一个警告窗口‘我是一个占位符’
</code></pre>
<p>二元运算符 + - * /</p>
<p>+= -=</p>
<p>++ --</p>
<p>=== !== &gt; &lt;</p>
<p>条件语句：</p>
<pre><code class="language-js">//C风格
if (){}
</code></pre>
<h2 id="事件">事件</h2>
<p>事件就是浏览器中发生的事儿，比如点击按钮、加载页面、播放视频，等等，</p>
<p>侦听事件发生的结构称为<strong>事件监听器（Event Listener）</strong>，响应事件触发而运行的代码块被称为<strong>事件处理器（Event Handler）</strong>。</p>
<pre><code class="language-js">guessSubmit.addEventListener('click', checkGuess);
</code></pre>
<p>这里为guessSubmit常量，也就是前面定义的<code>class guessSubmit</code>的引用，添加了一个事件监听器。<code>click</code>是事件的类型，<code>checkGuess</code>是<a href="https://developer.mozilla.org/zh-CN/docs/Web/Events">事件</a>发生时想要执行的代码（函数名无括号）。</p>
<h2 id="for循环">for循环</h2>
<p><code>C</code>风格<code>for (let i = 0; i &lt; 10; i++){}</code></p>
<h2 id="对象">对象</h2>
<pre><code class="language-js">guessField.focus();
//聚焦于 guessField，提高可用性。
</code></pre>
<p><code>guessField</code> 是 HTML 中表单的引用。</p>
<p>使用 <code>document</code> 对象的 <code>querySelector()</code> 方法可以获得这个引用。querySelector() 需要一个信息——用一个 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Selectors">CSS选择器</a> 可以选中需要引用的元素。</p>
<p>现在，<code>guessField</code> 的属性和方法就是 HTML 中表单的属性和方法。例如 <code>focus()</code> 就是其中之一。</p>
<h2 id="操作对象">操作对象</h2>
<p><code>guessField.value = 'Hello';</code> 可以用来修改文本区域的值。</p>
<p><code>guesses.value</code> 返回文本区域的值。</p>
<h2 id="代码">代码</h2>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;

    &lt;title&gt;猜数字游戏&lt;/title&gt;

    &lt;style&gt;
        html {
            font-family: sans-serif;
        }

        body {
            width: 50%;
            max-width: 800px;
            min-width: 480px;
            margin: 0 auto;
        }

        .lastResult {
            color: white;
            padding: 3px;
        }
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h1&gt;猜数字游戏&lt;/h1&gt;

    &lt;p&gt;我刚才随机选定了一个100以内的自然数。看你能否在 10 次以内猜中它。每次我都会告诉你所猜的结果是高了还是低了。&lt;/p&gt;

    &lt;div class=&quot;form&quot;&gt;
        &lt;label for=&quot;guessField&quot;&gt;请猜数: &lt;/label&gt;
        &lt;input type=&quot;text&quot; id=&quot;guessField&quot; class=&quot;guessField&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;确定&quot; class=&quot;guessSubmit&quot;&gt;
    &lt;/div&gt;

    &lt;div class=&quot;resultParas&quot;&gt;
        &lt;p class=&quot;guesses&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;lastResult&quot;&gt;&lt;/p&gt;
        &lt;p class=&quot;lowOrHi&quot;&gt;&lt;/p&gt;
    &lt;/div&gt;

    &lt;script&gt;

        let randomNumber = Math.floor(Math.random() * 100) + 1;

        const guesses = document.querySelector('.guesses');
        const lastResult = document.querySelector('.lastResult');
        const lowOrHi = document.querySelector('.lowOrHi');

        const guessSubmit = document.querySelector('.guessSubmit');
        const guessField = document.querySelector('.guessField');

        let guessCount = 1;
        let resetButton;

        guessSubmit.addEventListener('click', checkGuess);

        function checkGuess() {
            let userGuess = Number(guessField.value);
            if (Number.isInteger(userGuess) &amp;&amp; userGuess &lt; 100 &amp;&amp; userGuess &gt; 0) {
                if (guessCount === 1) {
                    guesses.textContent = '上次猜的数：';
                }
                guesses.textContent += userGuess + ' ';

                if (userGuess === randomNumber) {
                    lastResult.textContent = '恭喜你！猜对了';
                    lastResult.style.backgroundColor = 'green';
                    lowOrHi.textContent = '';
                    setGameOver();
                } else if (guessCount === 10) {
                    lastResult.textContent = '!!!GAME OVER!!!';
                    setGameOver();
                } else {
                    lastResult.textContent = '你猜错了！';
                    lastResult.style.backgroundColor = 'red';
                    if (userGuess &lt; randomNumber) {
                        lowOrHi.textContent = '你猜低了！';
                    } else if (userGuess &gt; randomNumber) {
                        lowOrHi.textContent = '你猜高了';
                    }
                }
            }
            else {
                alert('请输入0-100的整数！');
            }
            guessCount++;
            guessField.value = '';
            guessField.focus();
        }


        function setGameOver() {
            guessField.disabled = true;
            guessSubmit.disabled = true;
            resetButton = document.createElement('button');
            resetButton.textContent = '开始新游戏';
            document.body.appendChild(resetButton);
            resetButton.addEventListener('click', resetGame);
        }

        function resetGame() {
            guessCount = 1;

            const resetParas = document.querySelectorAll('.resultParas p');
            for (let i = 0; i &lt; resetParas.length; i++) {
                resetParas[i].textContent = '';
            }

            resetButton.parentNode.removeChild(resetButton);

            guessField.disabled = false;
            guessSubmit.disabled = false;
            guessField.value = '';
            guessField.focus();

            lastResult.style.backgroundColor = 'white';

            randomNumber = Math.floor(Math.random() * 100) + 1;
        }
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h1 id="总结">总结</h1>
<p>原本我是有点看不起例如 JavaScript、Typescript之类的脚本语言的，觉得他们是给<em>想跳过数据结构、算法、计算机网络、操作系统的学习，趁着互联网热分一杯羹的非计算机专业的外行</em>设计的。我这样想，和那些对 Python 嗤之以鼻，认为 C++、Java 才是正统编程的人有什么区别呢。我能接受 Python ，何不接受 JavaScript 呢？</p>
<p>计算机行业特别是互联网行业正在向<strong>轻量</strong>、<strong>易用</strong>发展。这次学习源于前几天想着要给大一做的出入校管理系统写个过得去的前端（原来是后端返回信息，C 在终端打印），让其成为一个算得上web应用的东西。然后让我惊讶的是我要么用 Tomcat 直接 print 一整个 HTML 页面出来，要么去学前端框架，也就必须要学 JavaScript。毫无疑问我选了后者，我有的是时间。</p>
<p>这是我事实上第一次学习 JavaScript，最大的感受是没有学习 C、Java 等刚开始配置环境的苦痛，怪不得脚本语言这么流行呢。同时一些基本的语法和 C 几乎一样，好感++。</p>
<p>更让我惊喜的是mozilla竟然有<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript">教程</a>！！还是中文的！！这和学习某些只能去b站看那些读ppt的语言&amp;工具相比实在是太友好了。而且中文版也不是机翻的，虽然是基于英文版写的，但完全进行了本地化。</p>
<p>还想吐槽一下上学期的web课老师，一个学期过去了他都没提到 JavaScript 代码和 HTML 元素的前后顺序导致的问题。遇到的时候去问他也只是含糊的告诉我把脚本放在后面试试。</p>
<p>我会继续学下去的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VMWare中使用ArchLinux的第一步]]></title>
        <id>https://freejool.github.io/post/archlinux/</id>
        <link href="https://freejool.github.io/post/archlinux/">
        </link>
        <updated>2022-02-21T01:01:23.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h2 id="title-在vmware中使用archlinux的第一步date-2022-02-21-090123tags-published-falsehideinlist-falsefeatureistop-false">title: '在VMWare中使用ArchLinux的第一步'<br>
date: 2022-02-21 09:01:23<br>
tags: []<br>
published: false<br>
hideInList: false<br>
feature:<br>
isTop: false</h2>
<p>本文旨在记录我在VMWare中安装Archlinux的过程和中间遇到的坑。<br>
参考：<a href="https://wiki.archlinux.org/title/Installation_guide">Installation_guide - ArchWiki</a>、<a href="https://www.cnblogs.com/cralor/p/13773986.html">VMware Workstation 安装 Arch Linux - cnblogs</a></p>
<h1 id="安装">安装</h1>
<h2 id="创建虚拟机">创建虚拟机</h2>
<p>在<a href="https://archlinux.org/download/">Arch Linux - Downloads</a>下方的源中选择China中的任一服务器，下载名为archlinux-<em>version</em>-x86_64.iso的文件。</p>
<p>打开VMWare，新建虚拟机，CPU4核4线程，RAM2G，硬盘20G，其他Linux版本，内核5.x（可以在<a href="https://archlinux.org/download/">Arch Linux - Downloads</a>中找到），并选择好虚拟机本体和虚拟硬盘的位置（推荐储存在固态硬盘）。完成之后，在启动虚拟机之前，打开高级设置，关闭测通道缓解（虽然不知道有什么用但是每次开机跳出来很烦），切换引导方式为<strong>UEFI</strong>。</p>
<h2 id="启动到live环境">启动到LIVE环境</h2>
<p>开启虚拟机。进入到一个类似Windows的PE环境的专门用来安装和初始化ArchLinux的环境。之后将在这里完成硬盘分区、基础软件包安装等工作。</p>
<h2 id="检查网络">检查网络</h2>
<p>一般来说VMWare会自动配置好，但是以防万一还是先检查一下，因为在分区结束后会通过网络安装基础软件包，到时候才发现就晚了👀。</p>
<p><code>ping baidu.com</code></p>
<h2 id="分区和格式化">分区和格式化</h2>
<p>首先使用<code>lsblk</code>来检查初始状态</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/xy-shen/my-image-beg/raw/master/imgs//1375263-20201006160335886-1419492587.png" alt="" loading="lazy"></figure>
<p>名为<strong>sda</strong>的就是要操作的硬盘，其余的是LIVE环境的虚拟空间。</p>
<p>我选择将硬盘分为3个区。（可以参考<a href="https://wiki.archlinux.org/title/Installation_guide#Partition_the_disks">官方文档</a>来获得如何选择分区的提示）</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/xy-shen/my-image-beg/raw/master/imgs//20220221093359.png" alt="" loading="lazy"></figure>
<ul>
<li>efi 512M 储存系统引导信息</li>
<li>swap 2G 内存交换区</li>
<li>/ 剩余空间（17.5G）系统空间</li>
</ul>
<p>分区命令：<code>cfdisk /dev/sda</code>  其中sda是之前<code>lsblk</code>中的设备名称，也可以用fdisk。</p>
<p>分区表类型选择GPT，并按照提示设定分区大小。</p>
<h3 id="展示四个分区的初始状态">展示四个分区的初始状态</h3>
<pre><code>lsblk
</code></pre>
<h3 id="格式化三个分区">格式化三个分区</h3>
<pre><code>mkfs.fat -F 32 /dev/sda1
mkswap /dev/sda2
mkfs.ext4 /dev/sda3
</code></pre>
<h3 id="挂载三个分区">挂载三个分区</h3>
<h4 id="创建efi文件夹挂载efi分区">创建efi文件夹,挂载efi分区</h4>
<pre><code>mkdir /mnt/efi
mount /dev/sda1 /mnt/efi
</code></pre>
<h4 id="swap分区无需挂载-但需要启用">swap分区无需挂载, 但需要启用</h4>
<pre><code>swapon /dev/sda2
</code></pre>
<h4 id="挂载mnt分区这里的mnt目录-就是真实arch的根目录">挂载mnt分区(这里的mnt目录, 就是真实Arch的根目录)</h4>
<pre><code>mount /dev/sda3 /mnt
</code></pre>
<h3 id="展示挂载后的四个分区">展示挂载后的四个分区</h3>
<pre><code>lsblk
</code></pre>
<h2 id="安装archlinux">安装Archlinux</h2>
<h3 id="选择国内的pacman镜像源">选择国内的Pacman镜像源</h3>
<p>将<a href="https://archlinux.org/mirrorlist/?country=CN&amp;protocol=http&amp;protocol=https&amp;ip_version=4">中国大陆的pacman镜像列表</a>输入到<code>/etc/pacman.d/mirrorlist</code></p>
<h3 id="安装基本包">安装基本包</h3>
<pre><code>pacstrap /mnt base base-devel linux linux-firmware dhcpcd
</code></pre>
<p>不知道是什么原因导致安装后没有DHCP服务，导致无法联网，于是在这里手动添加安装项。</p>
<h3 id="配置fstab">配置Fstab</h3>
<p>生成已挂载分区的fstab文件，执行以下命令：</p>
<pre><code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab
</code></pre>
<p>检查是否正确，文件系统被正确挂载<code>cat /mnt/etc/fstab</code>。</p>
<h3 id="切换到新系统chroot">切换到新系统Chroot</h3>
<pre><code>arch-chroot /mnt
</code></pre>
<h3 id="设置时区">设置时区</h3>
<p>把<code>localtime</code>软连接到当前时区</p>
<pre><code>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
</code></pre>
<h3 id="设置locale语言选项">设置Locale，语言选项</h3>
<p>在 <code>/etc/locale.gen</code> 中找到<code>zh_CN.UTF-8 UTF-8</code>  <code>en_US.UTF-8 UTF-8</code> 这两行，去掉行首的#号，保存并退出</p>
<p>更新Locale信息<code>locale-gen</code></p>
<p>设定语言，注意在这里不能设置中文，会导致shell乱码</p>
<p>在<code>vim /etc/locale.conf</code>中添加<code>LANG=en_US.UTF-8</code></p>
<h3 id="设置主机名">设置主机名</h3>
<p>在新文件<code>/etc/hostname</code>中输入一个名字，它将作为这个系统的主机名，下文称之myhostname。</p>
<p>添加如下内容到<code>/etc/hosts</code>，该文件的作用与Windows上的hosts类似。</p>
<pre><code>127.0.0.1    localhost
::1          localhost
127.0.1.1    myhostname.localdomain    myhostname
</code></pre>
<h3 id="设置root密码">设置Root密码</h3>
<pre><code>passwd
</code></pre>
<h3 id="安装系统引导工具grub-并生成引导文件">安装系统引导工具grub, 并生成引导文件</h3>
<p>检查引导方式，上文提到已经改成了UEFI。</p>
<pre><code>ls /sys/firmware/efi/efivars
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/xy-shen/my-image-beg/raw/master/imgs//20220221162406.png" alt="" loading="lazy"></figure>
<p>如果命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。 如果目录不存在，则系统可能以 BIOS 模式 (或 CSM 模式) 引导。</p>
<p>安装<strong>GRUB</strong><code>pacman -S grub</code></p>
<p>配置<strong>GRUB</strong><code>grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB</code></p>
<p>生成默认配置文件<code>grub-mkconfig -o /boot/grub/grub.cfg</code></p>
<p>以上参见<a href="https://wiki.archlinux.org/title/GRUB#Installation_2">GRUB - ArchWiki #installation</a></p>
<h3 id="配置网络">配置网络</h3>
<p>（注意是dhcpcd而不是dhcpd，后者是dhcp服务端而不是客户端）</p>
<p><code>systemctl enable dhcpcd</code></p>
<h3 id="退出重启">退出重启</h3>
<p>退出已经暂时配置好的系统</p>
<p><code>exit</code></p>
<p>解除CD挂载, 重启虚拟机</p>
<pre><code>umount -R /mnt
reboot
</code></pre>
<p>至此ArchLinux已经安装完成，重启后即可使用root用户进入系统。为了提高ArchLinux的易用性，接下来将对其进行简单的配置，包括安装图形界面。</p>
<h1 id="安装后配置">安装后配置</h1>
<p>先通过root账户登录系统，使用<a href="#%E8%AE%BE%E7%BD%AEroot%E5%AF%86%E7%A0%81">上文</a>的密码</p>
<h2 id="新建普通用户">新建普通用户</h2>
<pre><code>useradd -m -G wheel username
</code></pre>
<h2 id="配置sudo">配置sudo</h2>
<pre><code>pacman -S sudo
ln -s /usr/bin/vim /usr/bin/vi
visudo
</code></pre>
<p>在文件中找到<code># %wheel ALL=(ALL:ALL) ALL</code>，去掉前面的<code>#</code>，这就意味着wheel组内的所有用户都可以使用sudo。</p>
<p>这时候可以重启，并用刚刚创建的用户来登录。</p>
<h2 id="安装图形界面">安装图形界面</h2>
<pre><code>sudo pacman -S xorg plasma kde-applications sddm networkmanager network-manager-applet
sudo systemctl enable sddm
sudo systemctl enable NetworkManager
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://freejool.github.io/post/hello-gridea/</id>
        <link href="https://freejool.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>